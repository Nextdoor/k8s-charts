# -- The number of Pods to start up by default
replicaCount: 1

# -- Set up a PodDisruptionBudget for the Deployment
podDisruptionBudget: {}

image:
  # -- (String) The Docker image name and repository for your application
  repository: nginx

  # -- (String) Always, Never or IfNotPresent
  pullPolicy: IfNotPresent

  # -- (String) Overrides the image tag whose default is the chart appVersion.
  tag: ~

# An optional proxy sidecar configuration is provided - but its a rough
# beginning here, it doesn't provide any real configuration for the proxy, so
# we expect that the proxy container is preconfigured (for example,
# Okta-proxy). In the future we'll add support in for creating ConfigMaps and
# Secrets that can be bound into the sidecar container for a more complete
# solution.
proxySidecar:
  # -- (Boolean) Enables injecting a pre-defined reverse proxy sidecar
  # container into the Pod containers list.
  enabled: false

  # -- (String) The name of the proxy sidecar container
  name: proxy

  image:
    # -- (String) The Docker image name and repository for the sidecar
    repository: nginx

    # -- (String) The Docker tag for the sidecar
    tag: latest

    # -- (String) Always, Never or IfNotPresent
    pullPolicy: Always

  # -- Environment Variables for the primary container. These are all run
  # through the tpl function (the key name and value), so you can dynamically
  # name resources as you need.
  env: []

  # -- A PodSpec "Resources" object for the proxy container
  resources: {}

# -- A PodSpec container "livenessProbe" configuration object. Note that this
# livenessProbe will be applied to the proxySidecar container instead if that
# is enabled.
livenessProbe:
  httpGet:
    path: /
    port: http

# -- A PodSpec container "readinessProbe" configuration object. Note that this
# readinessProbe will be applied to the proxySidecar container instead if that
# is enabled.
readinessProbe:
  httpGet:
    path: /
    port: http

# -- A list of Port objects that are exposed by the service. These ports are
# applied to the main container, or the proxySidecar container (if enabled).
# The port list is also used to generate Network Policies that allow ingress
# into the pods.
ports:
  - name: http
    containerPort: 80
    protocol: TCP
  - name: https
    containerPort: 443
    protocol: TCP

# -- Supply a reference to a Secret that can be used by Kubernetes to pull down
# the Docker image. This is only used in local development, in combination with
# our `kube_create_ecr_creds` function from dotfiles.
imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# -- Environment Variables for the primary container. These are all run
# through the tpl function (the key name and value), so you can dynamically
# name resources as you need.
env: []
  # Example
  # - name: VAR
  #   value: MyString
  #
  # - name: MY-DYNAMIC-VAR-{{ .Release.Name }}
  #   value:
  #     secretKeyRef:
  #       name: {{ .Release.Name }}-secret
  #       key: foo
  #

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  port: 80

# Configuration for creating a dedicated ALB for your service. This is
# acceptable - but not the preferred method (see the IngressGateway setup
# below).
ingress:
  enabled: false
  annotations:
    alb.ingress.kubernetes.io/actions.ssl-redirect: >-
      {
        "Type": "redirect",
        "RedirectConfig": {
          "Protocol": "HTTPS",
          "Port": "443",
          "StatusCode": "HTTP_301"
        }
      }
  hosts:
    - host: chart-example.local
      path: ''
      sslRedirect: true  # ties into "actions.ssl-redirect" above
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# Configuration for creating a VirtualService inside the Istio Service Mesh
# Ingress Gateways. This is the preferred method for exposing a service because
# we have far greater visbility and granularity into the performance, it costs
# less, and deployments are actually faster this way.
ingressGateway:
  # -- (Boolean) Maps the Service to an Istio IngressGateway, exposing the
  # service outside of the Kubernetes cluster.
  enabled: false
  annotations: {}
  port: 80
  hosts: |-
    - {{ include "simple-app.fullname" . }}.{{ .Release.Namespace }}
  gateway: default-gateway
  namespace: istio-system
  tls: ""
  # -- (String) VirtualService "http" blob in text-form. This is run through
  # the tpl function so you may use template variables here.
  http: |-
    - match:
        - uri:
            prefix: /
      route:
        - destination:
            host: {{ include "simple-app.fullname" . }}
            port:
              number: {{ .Values.ingressGateway.port }}

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# Enabling Horizontal Pod Autoscaling (HPA) ensures that your application
# scales up to meet demand.
autoscaling:
  # -- Controls whether or not an HorizontalPodAutoscaler resource is created.
  enabled: false
  # -- Sets the minimum number of Pods to run
  minReplicas: 1
  # -- Sets the maximum number of Pods to run
  maxReplicas: 100
  # -- Configures the HPA to target a particular CPU utilization percentage
  targetCPUUtilizationPercentage: 80
  # -- If supplied, configures the HPA to target a particular Memory utilization percentage
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}

tests:
  connection:
    # -- The command used to trigger the test.
    command: ['curl']
    # -- A list of arguments passed into the command. These are run through the tpl function.
    args:
      - '{{ include "simple-app.fullname" . }}:{{ .Values.service.port }}'
    # By default, we actually use the source-image for the main application as
    # the image for testing, This allows the image to contain its own "client"
    # (curl, in this example) for testing the application. Alternatively, you
    # can configure your own testing image.
    image:
      # -- Sets the image-name that will be used in the "connection"
      # integration test. If this is left empty, then the .image.repository
      # value will be used instead (and the .image.tag will also be used).
      repository:
      # -- Sets the tag that will be used in the "connection" integration test.
      # If this is left empty, the default is "latest"
      tag:
